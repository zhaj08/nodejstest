var mysql = require('mysql');
var Cache = require("mem-cache");
var winston = require("winston");
var Moment = require('moment');
var uuid = require("node-uuid");

function initLogger() {
    "use strict";
    var levelIndex = process.argv.indexOf("--level"),
        level = ((levelIndex > -1) ? process.argv[levelIndex + 1] : "info");

    winston.clear();
    winston.add(winston.transports.Console,
                { colorize: true, level: level, label: "MySQL",
                    'timestamp': function () {var m = new Moment(); return m.format("YYYY-MM-DD HH:mm:ss"); } });
}

initLogger();

module.exports =  function (config) {
    "use strict";
    winston.info("Constructor. Start");
    winston.debug("Constructor configuration: ", config);

    //Validate config object iterating over the properties names
    function validate(config, mandatoryProperties) {
        if (typeof config !== 'object') {throw new Error("'config' argument must be an object instance."); }

        mandatoryProperties.forEach(function (property) {
            if (!config[property]) {throw new Error("'" + property + "' property is missing."); }
        });

    }

    validate(config, ["host", "port", "database"]);
    var self = this,
        initialConfig = config,
        timeout = initialConfig.timeout || (15 * 60 * 1000), //default 15 minutes;
        cacheAuthByUser = new Cache({timeout: timeout}),
        cacheConnectionByAuth = new Cache({timeout: timeout});

    cacheAuthByUser.on('expired', function (cacheEntry) {
        winston.debug("Expired Cache entry (AuthByUser):" + cacheEntry);
    });

    cacheConnectionByAuth.on('expired', function (cacheEntry) {
        winston.debug("Expired Cache entry (ConByAuth):" + cacheEntry);
        cacheEntry.value.connection.end();//Close connection
    });

    self.authenticate = function (data, cb) {
        winston.debug("authenticate");
        winston.verbose("authenticate data:", data);
        // Validates user credentials
        var username = data.username || initialConfig.username,
            password = data.password || initialConfig.password,
            connectiondata = {host: initialConfig.host,
                                port: initialConfig.port,
                                database: initialConfig.database,
                                user: username, //mysql expects a "user" property
                                password: password},
            connection = mysql.createConnection(connectiondata);

        connection.on('error', function (err) {
            if (err.code === "PROTOCOL_CONNECTION_LOST") {
                winston.warn(err);
            } else {
                winston.error(err);
            }
        });

        connection.connect(function (error) {
            if (error) {return cb(error, null); }

            var authToken = uuid.v4(), //Generate auth token 
                authItem = {
                    username: username,
                    password: password,
                    connection: connection
                };
            cacheConnectionByAuth.set(authToken, authItem);
            cacheAuthByUser.set(username, authToken);
            cb(null, {auth: authToken});
            return;
        });
    };

    self.query = function (data, cb) {
        winston.debug("query");
        winston.verbose("query data:", data);
        var authItem,
            queryFx = function () {
                authItem.connection.query(data.sql, data.values, cb);
            };

        if (!data.sql) {
            winston.debug("no sql parameter");
            return cb(new Error("No sql parameter"));
        }

        if (data.auth) {
            authItem = cacheConnectionByAuth.get(data.auth);
            if (!authItem) {return cb(new Error('Invalid Authorization Token')); }

            return queryFx();
        }
        winston.debug("query with no authToken");
        self.authenticate(data, function (error, authData) {
            if (error) {return cb(error); }

            authItem = cacheConnectionByAuth.get(authData.auth);
            return queryFx();
        });
    };

    self.close = function (cb) {
        winston.debug("closing connector");

        var count = 0;
        cacheConnectionByAuth.keys.forEach(function (authToken) {
            var authItem = cacheConnectionByAuth.remove(authToken);
            if (authItem) {
                count++;
                //Close connection
                authItem.connection.end(function (err) {
                    count--;
                    if (err) { winston.warn("Error closing connection.", err); }
                    if (count === 0) { cb(); }
                });
            }
        });

        if (count === 0) { cb(); }
    };
};


